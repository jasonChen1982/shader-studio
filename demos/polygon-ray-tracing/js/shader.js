var vertexShader = "#define GLSLIFY 1\nvarying vec4 vPosition;\n\nvoid main() {\n  vPosition = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n  gl_Position = vPosition;\n}\n"; // eslint-disable-line

var fragmentShader = "#define GLSLIFY 1\nuniform vec2 iResolution;\nuniform float iTime;\nuniform float iTimeDelta;\n\n// Use this to toggle between taking 1 sample of the heightfield and taking\n// 3 samples (to fully construct the triangle on every step).\n#define SINGLE_SAMPLE 1\n\nfloat minh = 0.0, maxh = 6.0;\nvec3 nn = vec3(0);\n\nfloat hash(float n)\n{\n  return fract(sin(n) * 43758.5453);\n}\n\nfloat noise(vec3 p)\n{\n  return hash(p.x + p.y*57.0 + p.z*117.0);\n}\n\nfloat valnoise(vec3 p)\n{\n  vec3 c = floor(p);\n  vec3 f = smoothstep(0., 1., fract(p));\n  return mix(\n      mix (mix(noise(c + vec3(0, 0, 0)), noise(c + vec3(1, 0, 0)), f.x),\n            mix(noise(c + vec3(0, 1, 0)), noise(c + vec3(1, 1, 0)), f.x), f.y),\n      mix (mix(noise(c + vec3(0, 0, 1)), noise(c + vec3(1, 0, 1)), f.x),\n            mix(noise(c + vec3(0, 1, 1)), noise(c + vec3(1, 1, 1)), f.x), f.y),\n      f.z);\n}\n\nfloat fbm(vec3 p)\n{\n  float f = 0.;\n  for(int i = 0; i < 5; ++i)\n      f += (valnoise(p * exp2(float(i))) - .5) / exp2(float(i));\n  return f;\n}\n\nfloat height(vec2 p)\n{\n  float h = mix(minh, maxh * 1.3, pow(clamp(.2 + .8 * fbm(vec3(p / 10., 0.)), 0., 1.), 1.3));\n  // h += valnoise(vec3(p, .3));\n  return h;\n}\n\n// The raytracing function\nvec3 tr2(vec3 o,vec3 r)\n{\n  // Start ray at upper Y bounds\n  if(o.y > maxh) o += r * (maxh - o.y) / r.y;\n\n  vec2 oc = vec2(floor(o.x), floor(o.z)), c;\n  vec2 dn = normalize(vec2(-1, 1));\n  vec3 ta, tb, tc;\n\n  // Initialise the triangle vertices\n  ta = vec3(oc.x, height(oc + vec2(0, 0)), oc.y);\n  tc = vec3(oc.x + 1., height(oc + vec2(1, 1)), oc.y + 1.);\n  if(fract(o.z) < fract(o.x))\n      tb = vec3(oc.x + 1., height(oc + vec2(1, 0)), oc.y + 0.);\n  else\n      tb = vec3(oc.x, height(oc + vec2(0, 1)), oc.y + 1.);\n\n  float t0 = 1e-4, t1;\n\n  // Ray slopes\n  vec2 dd = vec2(1) / r.xz;\n  float dnt = 1.0 / dot(r.xz, dn);\n\n  float s = max(sign(dnt), 0.);\n  c = ((oc + max(sign(r.xz), 0.)) - o.xz) * dd;\n\n  vec3 rs = sign(r);\n\n  for(int i = 0; i < 450; ++i)\n  {\n    t1 = min(c.x, c.y);\n\n    // Test ray against diagonal plane\n    float dt = dot(oc - o.xz, dn) * dnt;\n    if(dt > t0 && dt < t1)\n        t1 = dt;\n\n#if !SINGLE_SAMPLE\n    // Sample the heightfield for all three vertices.\n    vec2 of = (dot(o.xz + r.xz * (t0 + t1) * .5 - oc, dn) > 0.) ? vec2(0, 1) : vec2(1, 0);\n    tb = vec3(oc.x + of.x, height(oc + of), oc.y + of.y);\n    ta = vec3(oc.x, height(oc + vec2(0, 0)), oc.y);\n    tc = vec3(oc.x + 1., height(oc + vec2(1, 1)), oc.y + 1.);\n#endif\n\n    // Test ray against triangle plane\n    vec3 hn = cross(ta - tb, tc - tb);\n    float hh = dot(ta - o, hn) / dot(r, hn);\n\n    if(hh > t0 && hh < t1)\n    {\n        // Intersection with triangle has been found\n        nn = hn;\n        return o + r * hh;\n    }\n\n#if SINGLE_SAMPLE\n    vec2 offset;\n\n    // Get an \"axis selector\", which has 1.0 for the near (intersected) axis\n    // and 0.0 for the far one\n    vec2 ss = step(c, c.yx);\n\n    // Get the coordinate offset of where to read the next vertex height from\n    if(dt >= t0 && dt < c.x && dt < c.y)\n    {\n        offset = vec2(1. - s, s);\n    }\n    else\n    {\n        offset = dot(r.xz, ss) > 0. ? vec2(2, 1) : vec2(-1, 0);\n\n        if(c.y < c.x)\n            offset = offset.yx;\n    }\n\n    // Get the next vertex\n    vec3 tnew = vec3(oc + offset, height(oc + offset)).xzy;\n\n    // Update the triangle vertices.\n    if(dt >= t0 && dt < c.x && dt < c.y)\n    {\n        tb = tnew;\n    }\n    else\n    {\n        // Swap vertex order based on sign of ray axis\n        if(dot(r.xz, ss) > 0.)\n        {\n            ta = tb;\n            tb = tc;\n            tc = tnew;\n        }\n        else\n        {\n            tc = tb;\n            tb = ta;\n            ta = tnew;\n        }\n\n        // Step the grid coordinates along to the next cell\n        oc.xy += rs.xz * ss;\n        c.xy += dd.xy * rs.xz * ss;\n    }\n#else\n    // Get an \"axis selector\", which has 1.0 for the near (intersected) axis\n    // and 0.0 for the far one\n    vec2 ss = step(c, c.yx);\n\n    if(dt < t0 || dt >= c.x || dt >= c.y)\n    {\n        // Step the grid coordinates along to the next cell\n        oc.xy += rs.xz * ss;\n        c.xy += dd.xy * rs.xz * ss;\n    }\n\n#endif\n    t0 = t1;\n\n    // Test if the ray left the upper Y bounds\n    if(((maxh - o.y) / r.y < t0 && r.y > 0.) || t0 > 200.)\n        return vec3(10000);\n\n  }\n  return vec3(10000);\n}\n\n// Ray direction function\nvec3 rfunc(vec2 uv)\n{\n  vec3 r = normalize(vec3(uv.xy, -1.3));\n  // float ang = .7;\n  // r.yz *= mat2(cos(ang), sin(ang), -sin(ang), cos(ang));\n  return r;\n}\n\nfloat chequer(vec2 p)\n{\n  return step(0.5, fract(p.x + step(0.5, fract(p.y)) * 0.5));\n}\n\nvoid main() {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n  vec2 t = uv * 2. - 1. + 1e-3;\n  t.x *= iResolution.x / iResolution.y;\n\n  // Setup primary ray\n  vec3 o = vec3(0., 9.5, -iTime), r = rfunc(t);\n\n  // Trace primary ray\n  vec3 rp = tr2(o, r);\n\n  // Surface normal\n  vec3 n = normalize(nn);\n  if(n.y < 0.) n =- n;\n\n  // Checkerboard pattern\n  vec3 col = vec3(mix(.8, 1., chequer(rp.xz / 2.)));\n\n  if(fract(rp.z) < fract(rp.x)) col *= .7;\n\n  // Light direction\n  vec3 ld = normalize(vec3(1.5, 1, -2));\n\n  // // Directional shadow (raytraced)\n  // vec3 rp2 = tr2(rp + n*1e-4 + ld * 1e-4, ld);\n  // if(distance(rp, rp2) < 1000.) col *= .4 * vec3(.65, .65, 1);\n\n  // // Basic colouration\n  // col *= mix(vec3(1, .8, .5) / 2., vec3(.3, 1, .3) / 4., 1. - clamp(rp.y / 2., 0., 1.));\n  // col = mix(col, vec3(1) * .7, pow(clamp((rp.y - 2.5) / 2., 0., 1.), 2.));\n\n  // // Directional light falloff\n  // col *= pow(.5 + .5 * dot(n, ld), 1.);\n\n  // // Fog\n  // col = mix(vec3(.65, .65, 1), col, exp2(-distance(rp, o) / 1024.));\n\n  // // Clamp and gamma-correct\n  // col = pow(clamp(col * 2., 0., 1.), vec3(1. / 2.2));\n\n  // Output to screen\n  gl_FragColor = vec4(col, 1.0);\n}\n"; // eslint-disable-line

var Vector2 = THREE.Vector2;

var shader = {

  uniforms: {
    iResolution: {
      value: new Vector2(300, 150)
    },
    iTime: {
      value: 0.0
    },
    iTimeDelta: {
      value: 0.0
    },
  },

  vertexShader: vertexShader,

  fragmentShader: fragmentShader

};
